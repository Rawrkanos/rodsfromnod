<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rods from God: Orbital Dominion</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            color: #00ff00;
            padding: 10px;
            pointer-events: none;
        }
        #resources, #controls, #rod-status {
            background: rgba(0, 0, 0, 0.7);
            margin-bottom: 10px;
            padding: 10px;
            pointer-events: all;
        }
        button {
            background: #111;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 5px 10px;
            margin: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }
        button:hover {
            background: #00ff00;
            color: #000;
        }
        #targeting-info {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            color: #00ff00;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="ui">
        <div id="resources">
            Metal: <span id="metal">0</span> | Energy: <span id="energy">100</span>
        </div>
        <div id="controls">
            <button onclick="launchRod()">Launch Rod (50 Energy)</button>
            <button onclick="generateResources()">Generate Resources (+10 Metal, +20 Energy)</button>
            <button onclick="toggleTargeting()">Toggle Targeting</button>
        </div>
        <div id="rod-status">
            Active Rod: <br>
            Altitude: <span id="rod-altitude">N/A</span> km | 
            Speed: <span id="rod-speed">N/A</span> m/s | 
            Time to Impact: <span id="rod-time">N/A</span> s
        </div>
        <div id="targeting-info">
            Targeting Mode: <span id="targeting-mode">Off</span><br>
            Target: <span id="target-coords">None</span>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js" integrity="sha512-334uBDwY0iZ2TklV1OtDtBW9vp7jjP7SWRzT7Ehu1fdtPIjTpCwTSFb8HI/YBau9L1/kRBEOALrS229Kry4yFQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
        // Core Game State
        const state = {
            metal: 0,
            energy: 100,
            rods: [],
            targetingMode: false,
            target: null
        };

        // Scene Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000000);
        camera.position.set(0, 8000000, 12000000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas') });
        renderer.setSize(window.innerWidth, window.innerHeight);

        // Handle Window Resize
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });

        // Earth
        const earthRadius = 6371000; // Earth's radius in meters
        const earth = new THREE.Mesh(
            new THREE.SphereGeometry(earthRadius, 64, 64),
            new THREE.MeshPhongMaterial({
                color: 0x0066cc,
                shininess: 50,
                map: new THREE.TextureLoader().load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg')
            })
        );
        scene.add(earth);

        // Atmosphere
        const atmosphere = new THREE.Mesh(
            new THREE.SphereGeometry(earthRadius * 1.015, 64, 64),
            new THREE.MeshBasicMaterial({
                color: 0x00ccff,
                transparent: true,
                opacity: 0.3,
                side: THREE.BackSide
            })
        );
        scene.add(atmosphere);

        // Lighting
        const sunlight = new THREE.DirectionalLight(0xffffff, 1);
        sunlight.position.set(10000000, 10000000, 10000000);
        scene.add(sunlight);
        scene.add(new THREE.AmbientLight(0x222222));

        // Rod Template
        const rodGeometry = new THREE.CylinderGeometry(200, 200, 3000, 32);
        const rodMaterial = new THREE.MeshPhongMaterial({ color: 0xffaa00, emissive: 0xff5500, emissiveIntensity: 0 });

        // Particle System for Ejecta
        const particleCount = 5000;
        const particles = new THREE.Points(
            new THREE.BufferGeometry(),
            new THREE.PointsMaterial({ color: 0xccaa77, size: 500, transparent: true, blending: THREE.AdditiveBlending })
        );
        const particlePositions = new Float32Array(particleCount * 3);
        const particleVelocities = new Float32Array(particleCount * 3);
        const particleLives = new Float32Array(particleCount);
        particles.geometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        scene.add(particles);
        let particleSpawnIndex = 0;

        // Physics Constants
        const gravityConstant = 6.67430e-11; // m³ kg⁻¹ s⁻²
        const earthMass = 5.972e24; // kg

        // Raycaster for Targeting
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Targeting Click Handler
        window.addEventListener('click', (event) => {
            if (!state.targetingMode) return;
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(earth);
            if (intersects.length > 0) {
                state.target = intersects[0].point.clone();
                document.getElementById('target-coords').textContent = 
                    `X: ${state.target.x.toFixed(0)}, Z: ${state.target.z.toFixed(0)}`;
            }
        });

        // Game Functions
        function launchRod() {
            if (state.energy < 50) return;
            state.energy -= 50;

            const rod = new THREE.Mesh(rodGeometry, rodMaterial.clone());
            const startHeight = 20000000; // 20,000 km altitude
            const direction = state.target ? 
                state.target.clone().normalize() : 
                new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();
            rod.position.copy(direction.multiplyScalar(startHeight));
            rod.velocity = direction.clone().multiplyScalar(-15000); // Initial velocity: 15 km/s
            rod.mass = 10000; // 10 tons
            scene.add(rod);
            state.rods.push(rod);

            updateUI();
        }

        function generateResources() {
            state.metal += 10;
            state.energy += 20;
            updateUI();
        }

        function toggleTargeting() {
            state.targetingMode = !state.targetingMode;
            document.getElementById('targeting-mode').textContent = state.targetingMode ? 'On' : 'Off';
        }

        function spawnEjecta(impactPosition) {
            const ejectaCount = 1000;
            for (let i = 0; i < ejectaCount; i++) {
                const idx = (particleSpawnIndex + i) % particleCount;
                const angle = Math.random() * Math.PI * 2;
                const speed = 3000 + Math.random() * 5000;
                particlePositions[idx * 3] = impactPosition.x;
                particlePositions[idx * 3 + 1] = impactPosition.y;
                particlePositions[idx * 3 + 2] = impactPosition.z;
                particleVelocities[idx * 3] = Math.cos(angle) * speed;
                particleVelocities[idx * 3 + 1] = 2000 + Math.random() * 4000;
                particleVelocities[idx * 3 + 2] = Math.sin(angle) * speed;
                particleLives[idx] = 5 + Math.random() * 5;
            }
            particleSpawnIndex = (particleSpawnIndex + ejectaCount) % particleCount;
            particles.geometry.attributes.position.needsUpdate = true;
        }

        function updateUI() {
            document.getElementById('metal').textContent = state.metal;
            document.getElementById('energy').textContent = state.energy;
        }

        // Animation Loop
        let lastTime = performance.now();
        function animate(time) {
            const deltaTime = (time - lastTime) / 1000;
            lastTime = time;

            // Rotate Earth
            earth.rotation.y += deltaTime * 0.05;
            atmosphere.rotation.y += deltaTime * 0.05;

            // Update Rods
            let rodStatusUpdated = false;
            state.rods.forEach((rod, index) => {
                if (!rod) return;

                const distance = rod.position.length();
                const altitude = distance - earthRadius;

                if (altitude > 0) {
                    // Apply gravity
                    const gravitationalForce = gravityConstant * earthMass / (distance * distance);
                    const gravity = rod.position.clone().normalize().multiplyScalar(-gravitationalForce);
                    rod.velocity.add(gravity.multiplyScalar(deltaTime));

                    // Simple drag in atmosphere (below 100 km)
                    if (altitude < 100000) {
                        const dragFactor = 0.0005 * Math.exp(-altitude / 10000);
                        rod.velocity.multiplyScalar(1 - dragFactor);
                        rod.material.emissiveIntensity = Math.min(2, 100000 / altitude);
                    }

                    // Update position
                    rod.position.add(rod.velocity.clone().multiplyScalar(deltaTime));
                    rod.rotation.x += deltaTime * 0.8;
                    rod.rotation.z += deltaTime * 0.6;

                    // Update rod status (closest to impact)
                    if (!rodStatusUpdated) {
                        const speed = rod.velocity.length();
                        const timeToImpact = altitude / speed;
                        document.getElementById('rod-altitude').textContent = (altitude / 1000).toFixed(2);
                        document.getElementById('rod-speed').textContent = speed.toFixed(0);
                        document.getElementById('rod-time').textContent = timeToImpact.toFixed(2);
                        rodStatusUpdated = true;
                    }
                } else {
                    // Impact
                    spawnEjecta(rod.position);
                    scene.remove(rod);
                    state.rods[index] = null;
                }
            });
            state.rods = state.rods.filter(r => r !== null);

            if (!rodStatusUpdated) {
                document.getElementById('rod-altitude').textContent = 'N/A';
                document.getElementById('rod-speed').textContent = 'N/A';
                document.getElementById('rod-time').textContent = 'N/A';
            }

            // Update Particles
            for (let i = 0; i < particleCount; i++) {
                if (particleLives[i] > 0) {
                    particleVelocities[i * 3 + 1] -= 9.81 * deltaTime; // Gravity
                    particlePositions[i * 3] += particleVelocities[i * 3] * deltaTime;
                    particlePositions[i * 3 + 1] += particleVelocities[i * 3 + 1] * deltaTime;
                    particlePositions[i * 3 + 2] += particleVelocities[i * 3 + 2] * deltaTime;
                    particleLives[i] -= deltaTime;
                    if (particleLives[i] <= 0 || particlePositions[i * 3 + 1] < earthRadius) {
                        particlePositions[i * 3] = 0;
                        particlePositions[i * 3 + 1] = 0;
                        particlePositions[i * 3 + 2] = 0;
                    }
                }
            }
            particles.geometry.attributes.position.needsUpdate = true;

            // Camera orbit
            camera.position.x = Math.sin(time * 0.0001) * 12000000;
            camera.position.z = Math.cos(time * 0.0001) * 12000000;
            camera.lookAt(0, 0, 0);

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        // Start Game
        updateUI();
        requestAnimationFrame(animate);
    </script>
</body>
</html>

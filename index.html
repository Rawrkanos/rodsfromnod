<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Rods from God: Orbital Dominion</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Orbitron', sans-serif; }
        canvas { width: 100vw; height: 100vh; display: block; }
        #ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            color: #0f0; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
        }
        #resources { padding: 15px; background: rgba(0, 0, 0, 0.8); pointer-events: all; }
        #resources span { margin-right: 20px; font-size: 20px; text-shadow: 0 0 8px #0f0; }
        #controls { display: flex; flex-wrap: wrap; padding: 15px; background: rgba(0, 0, 0, 0.8); pointer-events: all; }
        #controls button {
            margin: 8px; padding: 12px 25px; background: #111; color: #0f0; border: 2px solid #0f0;
            cursor: pointer; font-size: 18px; transition: all 0.3s; text-transform: uppercase; border-radius: 5px;
        }
        #controls button:hover { background: #0f0; color: #000; box-shadow: 0 0 15px #0f0; }
        #status { padding: 15px; background: rgba(0, 0, 0, 0.8); text-align: center; font-size: 20px; }
        #map {
            position: absolute; bottom: 25px; right: 25px; width: 400px; padding: 15px;
            background: rgba(0, 0, 0, 0.9); border: 2px solid #0f0; font-size: 16px; border-radius: 5px;
        }
        #map div { margin: 8px 0; }
        #rod-info {
            position: absolute; top: 50%; left: 20px; padding: 10px;
            background: rgba(0, 0, 0, 0.7); font-size: 18px; text-shadow: 0 0 5px #0f0;
        }
        #alerts {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.7); padding: 20px; font-size: 24px; text-align: center;
            border: 2px solid #f00; display: none; color: #fff; text-shadow: 0 0 10px #f00;
        }
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="ui">
        <div id="resources">
            <span>Metal: <span id="metal">0</span></span>
            <span>Influence: <span id="influence">0</span></span>
            <span>Tech: <span id="tech">0</span></span>
        </div>
        <div id="controls">
            <button onclick="dropRod()">Launch Kinetic Strike</button>
            <button onclick="upgradeSatellites()">Deploy Satellite (50 Metal)</button>
            <button onclick="upgradeRods()">Increase Rods (100 Metal)</button>
            <button onclick="upgradePower()">Enhance Payload (150 Metal)</button>
            <button onclick="unlockAutomation()">Activate AI Control (200 Tech)</button>
            <button onclick="unlockPrecision()">Precision Guidance (500 Tech)</button>
            <button onclick="buildDyson()">Construct Dyson Swarm (10K Tech)</button>
            <button onclick="buildColossus()">Forge Rod Colossus (50K Tech)</button>
            <button onclick="generateMetal()">Generate Metal (+10)</button>
            <button onclick="resetWorld()">Initiate Orbital Reset</button>
        </div>
        <div id="status">
            Phase: <span id="phase">1</span> | Time: <span id="time">0</span>h | 
            Satellites: <span id="satellites">1</span> | Rods/Drop: <span id="rods">1</span> | 
            Power: <span id="rodPower">1</span>
        </div>
        <div id="map">
            <div>Geopolitical Theater:</div>
            <div>USA: <span id="usa">100</span>% Stability</div>
            <div>China: <span id="china">100</span>% Stability</div>
            <div>Russia: <span id="russia">100</span>% Stability</div>
            <div>EU: <span id="eu">100</span>% Stability</div>
        </div>
        <div id="rod-info">
            Rod Height: <span id="rod-height">N/A</span> km<br>
            Energy: <span id="rod-energy">N/A</span> GJ
        </div>
        <div id="alerts"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js" integrity="sha512-334uBDwY0iZ2TklV1OtDtBW9vp7jjP7SWRzT7Ehu1fdtPIjTpCwTSFb8HI/YBau9L1/kRBEOALrS229Kry4yFQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
        // Game State
        let gameState = {
            metal: 0, influence: 0, tech: 0,
            satellites: 1, rods: 1, rodPower: 1,
            automation: false, precision: false, dyson: false, colossus: false,
            phase: 1, timePlayed: 0, lastDrop: 0,
            nations: { usa: 100, china: 100, russia: 100, eu: 100 },
            defenses: 0
        };

        // Three.js Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 150000000);
        camera.position.set(0, 10000000, 25000000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000);

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });

        // Earth
        const earthRadius = 6371000;
        const earthGeometry = new THREE.SphereGeometry(earthRadius, 128, 128);
        const earthMaterial = new THREE.MeshPhongMaterial({
            color: 0x0066cc,
            shininess: 50,
            specular: 0x333333,
            map: new THREE.TextureLoader().load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg'),
            bumpMap: new THREE.TextureLoader().load('https://threejs.org/examples/textures/planets/earth_bump_2048.jpg'),
            bumpScale: 10000
        });
        const earth = new THREE.Mesh(earthGeometry, earthMaterial);
        scene.add(earth);

        // Atmosphere for Visual Flair
        const atmosphereGeometry = new THREE.SphereGeometry(earthRadius * 1.015, 128, 128);
        const atmosphereMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                glowColor: { value: new THREE.Color(0x00ccff) }
            },
            vertexShader: `
                varying vec3 vNormal;
                varying vec3 vPosition;
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                uniform vec3 glowColor;
                varying vec3 vNormal;
                varying vec3 vPosition;
                void main() {
                    float intensity = pow(0.8 - dot(vNormal, vec3(0, 0, 1)), 2.0);
                    gl_FragColor = vec4(glowColor, intensity * 0.5);
                }
            `,
            side: THREE.BackSide,
            blending: THREE.AdditiveBlending,
            transparent: true
        });
        const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
        scene.add(atmosphere);

        // Lighting
        const sunLight = new THREE.DirectionalLight(0xffffff, 1);
        sunLight.position.set(100000000, 100000000, 100000000);
        scene.add(sunLight);
        scene.add(new THREE.AmbientLight(0x333333));

        // Rods and Particles
        const rodGeometry = new THREE.CylinderGeometry(250, 250, 3000, 32);
        const rodMaterial = new THREE.MeshPhongMaterial({
            color: 0xaaaaaa,
            emissive: 0xff5500,
            emissiveIntensity: 0.5,
            shininess: 100
        });
        const rods = [];

        const particleGeometry = new THREE.BufferGeometry();
        const particleCount = 50000;
        const particlePositions = new Float32Array(particleCount * 3);
        const particleVelocities = new Float32Array(particleCount * 3);
        const particleLifetimes = new Float32Array(particleCount);
        particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        const particleMaterial = new THREE.PointsMaterial({
            color: 0xccaa77,
            size: 1000,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });
        const particles = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particles);
        let particleIndex = 0;

        // Physics Constants
        const G = 6.67430e-11;
        const M = 5.972e24;
        const earthMass = M;

        // Game Logic
        function dropRod() {
            if (Date.now() - gameState.lastDrop < 20000 / gameState.satellites) return;
            if (gameState.defenses > Math.random() * 100) {
                showAlert("Strike intercepted by defenses!");
                return;
            }
            gameState.lastDrop = Date.now();
            const dropCount = gameState.colossus && Math.random() < 0.15 ? 1 : gameState.rods;
            for (let i = 0; i < dropCount; i++) {
                const spread = gameState.precision ? 300000 : 1200000;
                const rod = new THREE.Mesh(rodGeometry, rodMaterial.clone());
                rod.position.set(
                    Math.random() * spread - spread / 2,
                    36000000,
                    Math.random() * spread - spread / 2
                );
                rod.velocity = new THREE.Vector3(0, -18000, 0);
                rod.mass = gameState.colossus && i === 0 ? 2000000 : 1000 * gameState.rodPower;
                rod.scale.set(1 + rod.mass * 0.0005, 1 + rod.mass * 0.0005, 1 + rod.mass * 0.0005);
                scene.add(rod);
                rods.push(rod);
            }
            gameState.metal += 30 * gameState.rodPower * dropCount;
            gameState.influence += 20 * gameState.rodPower * dropCount;
            gameState.tech += 10 * gameState.rodPower * dropCount;
            updateUI();
        }

        function upgradeSatellites() {
            if (gameState.metal >= 50) {
                gameState.metal -= 50;
                gameState.satellites += 1;
                updateUI();
            }
        }

        function upgradeRods() {
            if (gameState.metal >= 100) {
                gameState.metal -= 100;
                gameState.rods += 1;
                updateUI();
            }
        }

        function upgradePower() {
            if (gameState.metal >= 150) {
                gameState.metal -= 150;
                gameState.rodPower *= 1.25;
                updateUI();
            }
        }

        function unlockAutomation() {
            if (gameState.tech >= 200 && !gameState.automation) {
                gameState.tech -= 200;
                gameState.automation = true;
                showAlert("AI Control activated.");
                updateUI();
            }
        }

        function unlockPrecision() {
            if (gameState.tech >= 500 && !gameState.precision) {
                gameState.tech -= 500;
                gameState.precision = true;
                showAlert("Precision Guidance online.");
                updateUI();
            }
        }

        function buildDyson() {
            if (gameState.tech >= 10000 && !gameState.dyson) {
                gameState.tech -= 10000;
                gameState.dyson = true;
                showAlert("Dyson Swarm harvesting resources.");
                updateUI();
            }
        }

        function buildColossus() {
            if (gameState.tech >= 50000 && !gameState.colossus) {
                gameState.tech -= 50000;
                gameState.colossus = true;
                showAlert("Rod Colossus forged - annihilation imminent.");
                updateUI();
            }
        }

        function generateMetal() {
            gameState.metal += 10;
            updateUI();
        }

        function resetWorld() {
            if (gameState.phase >= 3) {
                gameState.metal *= 3.5;
                gameState.influence *= 3.5;
                gameState.tech *= 3.5;
                gameState.satellites = 1;
                gameState.rods = 1;
                gameState.rodPower = 1;
                gameState.automation = false;
                gameState.precision = false;
                gameState.dyson = false;
                gameState.colossus = false;
                gameState.phase = 1;
                gameState.timePlayed = 0;
                gameState.lastDrop = 0;
                gameState.nations = { usa: 100, china: 100, russia: 100, eu: 100 };
                gameState.defenses = 0;
                rods.forEach(rod => scene.remove(rod));
                rods.length = 0;
                particleIndex = 0;
                for (let i = 0; i < particleCount * 3; i++) {
                    particlePositions[i] = 0;
                    particleVelocities[i] = 0;
                }
                particleGeometry.attributes.position.needsUpdate = true;
                updateUI();
                showAlert("Orbital Reset initiated - new era begins.");
            }
        }

        function updateGeopolitics() {
            if (gameState.phase >= 2) {
                for (let nation in gameState.nations) {
                    gameState.nations[nation] -= gameState.rodPower * gameState.rods * 0.3;
                    if (gameState.nations[nation] <= 0) gameState.nations[nation] = 0;
                }
                if (gameState.phase === 3) {
                    gameState.defenses += 0.02;
                    if (Math.random() < 0.2) {
                        const rod = new THREE.Mesh(rodGeometry, rodMaterial.clone());
                        rod.position.set(
                            Math.random() * 1200000 - 600000,
                            36000000,
                            Math.random() * 1200000 - 600000
                        );
                        rod.velocity = new THREE.Vector3(0, -15000, 0);
                        rod.mass = 1500;
                        scene.add(rod);
                        rods.push(rod);
                        showAlert("Enemy counterstrike launched!");
                    }
                }
            }
            document.getElementById('usa').textContent = Math.floor(gameState.nations.usa);
            document.getElementById('china').textContent = Math.floor(gameState.nations.china);
            document.getElementById('russia').textContent = Math.floor(gameState.nations.russia);
            document.getElementById('eu').textContent = Math.floor(gameState.nations.eu);
        }

        function spawnEjecta(position, mass) {
            const ejectaCount = Math.min(Math.floor(mass * 0.1), 10000);
            for (let i = 0; i < ejectaCount; i++) {
                const angle = Math.random() * 2 * Math.PI;
                const speed = Math.random() * 8000 + 2000;
                const idx = (particleIndex + i) % particleCount;
                particlePositions[idx * 3] = position.x;
                particlePositions[idx * 3 + 1] = position.y;
                particlePositions[idx * 3 + 2] = position.z;
                particleVelocities[idx * 3] = Math.cos(angle) * speed;
                particleVelocities[idx * 3 + 1] = Math.random() * 10000 + 5000;
                particleVelocities[idx * 3 + 2] = Math.sin(angle) * speed;
                particleLifetimes[idx] = 5 + Math.random() * 5;
            }
            particleIndex = (particleIndex + ejectaCount) % particleCount;
            particleGeometry.attributes.position.needsUpdate = true;
        }

        function updateUI() {
            document.getElementById('metal').textContent = Math.floor(gameState.metal);
            document.getElementById('influence').textContent = Math.floor(gameState.influence);
            document.getElementById('tech').textContent = Math.floor(gameState.tech);
            document.getElementById('satellites').textContent = gameState.satellites;
            document.getElementById('rods').textContent = gameState.rods;
            document.getElementById('rodPower').textContent = gameState.rodPower.toFixed(2);
            document.getElementById('phase').textContent = gameState.phase;
            document.getElementById('time').textContent = (gameState.timePlayed / 3600).toFixed(1);
        }

        function showAlert(message) {
            const alerts = document.getElementById('alerts');
            alerts.textContent = message;
            alerts.style.display = 'block';
            setTimeout(() => alerts.style.display = 'none', 2000);
        }

        // Animation Loop
        let lastTime = performance.now();
        function animate(time) {
            const dtReal = (time - lastTime) / 1000;
            lastTime = time;

            gameState.timePlayed += dtReal;
            if (gameState.timePlayed > 3600 * 3) gameState.phase = 2;
            if (gameState.timePlayed > 3600 * 7) gameState.phase = 3;
            if (gameState.automation) dropRod();
            if (gameState.dyson) gameState.metal += dtReal * 40;

            // Update Rods
            rods.forEach((rod, index) => {
                if (!rod) return;

                const r = rod.position.length();
                const altitude = r - earthRadius;
                let simSpeed = 10; // 10x real-time default

                if (altitude > 0) {
                    // Physics
                    const gravity = new THREE.Vector3(0, 0, 0).sub(rod.position).normalize().multiplyScalar(G * M / (r * r));
                    let accel = gravity;
                    if (altitude < 120000) {
                        const density = Math.exp(-altitude / 7500) * 1.225;
                        const vMag = rod.velocity.length();
                        const drag = rod.velocity.clone().normalize().multiplyScalar(-0.5 * density * vMag * vMag * 0.015 / rod.mass);
                        accel.add(drag);
                    }
                    rod.velocity.add(accel.clone().multiplyScalar(dtReal * simSpeed));

                    // Dynamic Simulation Speed
                    const timeToImpact = altitude / rod.velocity.y; // Assuming mostly downward velocity
                    if (timeToImpact <= 5) {
                        simSpeed = Math.max(1, simSpeed * (timeToImpact / 5)); // Slow to real-time
                        if (timeToImpact <= 0.5) {
                            simSpeed = Math.max(0.1, simSpeed * (timeToImpact / 0.5)); // Slow to 1/10th
                        }
                    }
                    rod.position.add(rod.velocity.clone().multiplyScalar(dtReal * simSpeed));

                    // Update Rod Info
                    const energy = 0.5 * rod.mass * rod.velocity.lengthSq() / 1e9; // GJ
                    document.getElementById('rod-height').textContent = (altitude / 1000).toFixed(2);
                    document.getElementById('rod-energy').textContent = energy.toFixed(2);

                    // Reentry Glow
                    rod.material.emissiveIntensity = Math.min(2, 120000 / Math.max(10000, altitude));
                }

                // Impact
                if (altitude <= 1000) {
                    spawnEjecta(rod.position, rod.mass);
                    earthGeometry.scale(1 - rod.mass * 0.00000001, 1 - rod.mass * 0.00000001, 1 - rod.mass * 0.00000001); // Crude deformation
                    scene.remove(rod);
                    rods[index] = null;
                    updateGeopolitics();
                }
            });
            rods = rods.filter(r => r !== null);

            // Update Particles
            for (let i = 0; i < particleCount; i++) {
                if (particleLifetimes[i] > 0) {
                    particleVelocities[i * 3 + 1] -= 9.81 * dtReal * 10; // Gravity
                    particlePositions[i * 3] += particleVelocities[i * 3] * dtReal;
                    particlePositions[i * 3 + 1] += particleVelocities[i * 3 + 1] * dtReal;
                    particlePositions[i * 3 + 2] += particleVelocities[i * 3 + 2] * dtReal;
                    particleLifetimes[i] -= dtReal;
                    if (particleLifetimes[i] <= 0 || particlePositions[i * 3 + 1] < earthRadius) {
                        particlePositions[i * 3] = 0;
                        particlePositions[i * 3 + 1] = 0;
                        particlePositions[i * 3 + 2] = 0;
                    }
                }
            }
            particleGeometry.attributes.position.needsUpdate = true;

            // Camera and Earth Rotation
            earth.rotation.y += dtReal * 0.05;
            atmosphereMaterial.uniforms.time.value = time / 1000;

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        // Start
        updateUI();
        requestAnimationFrame(animate);
    </script>
</body>
</html>

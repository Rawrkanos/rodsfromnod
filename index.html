<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rods from God: Orbital Strike</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
        }
        button, select {
            margin: 5px;
            padding: 5px 10px;
            background: #333;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        button:hover, select:hover { background: #555; }
    </style>
</head>
<body>
    <div id="ui">
        <div>Altitude: <span id="altitude">0</span> km</div>
        <div>Velocity: <span id="velocity">0</span> m/s</div>
        <div>Impact Energy: <span id="energy">0</span> MJ</div>
        <div>Score: <span id="score">0</span></div>
        <div>Rods Remaining: <span id="rods">3</span></div>
        <select id="target">
            <option value="0">Random Target</option>
            <option value="1">City</option>
            <option value="2">Bunker</option>
            <option value="3">Mountain</option>
        </select>
        <select id="altitudeSelect">
            <option value="200000">200 km</option>
            <option value="400000">400 km</option>
            <option value="600000">600 km</option>
        </select>
        <button id="launch">Launch Rod</button>
        <button id="reset">Reset</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // Scene Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Ground
        const groundGeometry = new THREE.PlaneGeometry(10000, 10000);
        const groundMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x228B22, 
            specular: 0x050505,
            shininess: 10 
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Rod
        const rodRadius = 0.15; // 30 cm diameter
        const rodLength = 6.1;  // 20 feet
        const rodGeometry = new THREE.CylinderGeometry(rodRadius, rodRadius, rodLength, 32);
        const rodMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xB0C4DE,
            specular: 0x555555,
            shininess: 50 
        });
        const rod = new THREE.Mesh(rodGeometry, rodMaterial);
        rod.castShadow = true;
        rod.position.y = 400; // Initial visual height
        scene.add(rod);

        // Targets
        const targets = [];
        function createTarget(type, x, z) {
            let geometry, material, height;
            switch(type) {
                case 1: // City
                    geometry = new THREE.BoxGeometry(10, 5, 10);
                    material = new THREE.MeshPhongMaterial({ color: 0x808080 });
                    height = 2.5;
                    break;
                case 2: // Bunker
                    geometry = new THREE.BoxGeometry(5, 2, 5);
                    material = new THREE.MeshPhongMaterial({ color: 0x4B2E2A });
                    height = 1;
                    break;
                case 3: // Mountain
                    geometry = new THREE.ConeGeometry(10, 15, 32);
                    material = new THREE.MeshPhongMaterial({ color: 0x696969 });
                    height = 7.5;
                    break;
                default: // Random
                    return createTarget(Math.floor(Math.random() * 3) + 1, x, z);
            }
            const target = new THREE.Mesh(geometry, material);
            target.position.set(x, height, z);
            target.castShadow = true;
            target.receiveShadow = true;
            target.userData = { type, height };
            scene.add(target);
            targets.push(target);
            return target;
        }

        // Initial Targets
        createTarget(1, -20, 20);  // City
        createTarget(2, 30, -10);  // Bunker
        createTarget(3, 0, 30);    // Mountain

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);
        const sunLight = new THREE.DirectionalLight(0xffffff, 1);
        sunLight.position.set(500, 500, 500);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 1000;
        scene.add(sunLight);

        // Camera
        camera.position.set(0, 50, 100);
        camera.lookAt(0, 0, 0);

        // Physics Constants
        const G = 6.67430e-11; // Gravitational constant (m³/kg/s²)
        const M = 5.972e24;   // Earth's mass (kg)
        const R = 6.371e6;    // Earth's radius (m)
        const rodMass = 8700 * Math.PI * rodRadius * rodRadius * rodLength; // Tungsten density ~8700 kg/m³
        const dragCoefficient = 0.82; // Approximate for cylinder
        const airDensitySL = 1.225; // Sea level air density (kg/m³)

        // Simulation Variables
        let velocity = 0;     // m/s (negative is downward)
        let altitude = 400000; // m
        let isLaunched = false;
        let score = 0;
        let rodsRemaining = 3;
        let targetX = 0;
        let targetZ = 0;

        // UI Elements
        const altitudeDisplay = document.getElementById('altitude');
        const velocityDisplay = document.getElementById('velocity');
        const energyDisplay = document.getElementById('energy');
        const scoreDisplay = document.getElementById('score');
        const rodsDisplay = document.getElementById('rods');
        const launchButton = document.getElementById('launch');
        const resetButton = document.getElementById('reset');
        const targetSelect = document.getElementById('target');
        const altitudeSelect = document.getElementById('altitudeSelect');

        launchButton.addEventListener('click', launchRod);
        resetButton.addEventListener('click', resetSimulation);
        targetSelect.addEventListener('change', updateTargetPosition);
        altitudeSelect.addEventListener('change', () => {
            altitude = parseFloat(altitudeSelect.value);
            rod.position.y = altitude / 1000;
        });

        function launchRod() {
            if (rodsRemaining > 0 && !isLaunched) {
                isLaunched = true;
                rodsRemaining--;
                rodsDisplay.textContent = rodsRemaining;
            }
        }

        function resetSimulation() {
            isLaunched = false;
            velocity = 0;
            altitude = parseFloat(altitudeSelect.value);
            rod.position.set(targetX, altitude / 1000, targetZ);
            rod.rotation.set(0, 0, 0);
            score = 0;
            rodsRemaining = 3;
            scoreDisplay.textContent = score;
            rodsDisplay.textContent = rodsRemaining;
            targets.forEach(t => scene.remove(t));
            targets.length = 0;
            createTarget(1, -20, 20);
            createTarget(2, 30, -10);
            createTarget(3, 0, 30);
        }

        function updateTargetPosition() {
            const targetType = parseInt(targetSelect.value);
            if (targetType === 0) {
                targetX = (Math.random() - 0.5) * 50;
                targetZ = (Math.random() - 0.5) * 50;
            } else {
                const target = targets.find(t => t.userData.type === targetType);
                if (target) {
                    targetX = target.position.x;
                    targetZ = target.position.z;
                }
            }
            if (!isLaunched) rod.position.set(targetX, altitude / 1000, targetZ);
        }

        // Animation Loop
        function animate() {
            requestAnimationFrame(animate);

            if (isLaunched && altitude > 0) {
                const dt = 0.016; // 60 FPS timestep

                // Gravitational Acceleration
                const r = R + altitude;
                const gravity = -(G * M) / (r * r);

                // Atmospheric Drag
                const altitudeKm = altitude / 1000;
                const airDensity = altitudeKm < 100 ? airDensitySL * Math.exp(-altitudeKm / 7.5) : 0;
                const crossSection = Math.PI * rodRadius * rodRadius;
                const dragForce = 0.5 * airDensity * velocity * velocity * dragCoefficient * (velocity > 0 ? 1 : -1);
                const dragAcceleration = dragForce / rodMass;

                // Update Physics
                const totalAcceleration = gravity + dragAcceleration;
                velocity += totalAcceleration * dt;
                altitude += velocity * dt;
                rod.position.y = altitude / 1000;

                // Rod Orientation
                rod.rotation.x = Math.PI / 2 - Math.atan2(velocity, 100);

                // Impact Handling
                if (altitude <= 0) {
                    altitude = 0;
                    velocity = 0;
                    isLaunched = false;
                    handleImpact();
                }
            }

            // Update UI
            altitudeDisplay.textContent = (altitude / 1000).toFixed(2);
            velocityDisplay.textContent = Math.abs(velocity).toFixed(2);
            energyDisplay.textContent = ((0.5 * rodMass * velocity * velocity) / 1e6).toFixed(2);

            renderer.render(scene, camera);
        }

        // Impact Handling
        function handleImpact() {
            createImpactCrater(rod.position.x, rod.position.z);
            const hitTarget = targets.find(t => 
                Math.hypot(t.position.x - rod.position.x, t.position.z - rod.position.z) < 10
            );
            if (hitTarget) {
                const energy = (0.5 * rodMass * velocity * velocity) / 1e6; // MJ
                score += Math.floor(energy * (hitTarget.userData.type === 2 ? 2 : 1)); // Bonus for bunkers
                scoreDisplay.textContent = score;
                scene.remove(hitTarget);
                targets.splice(targets.indexOf(hitTarget), 1);
            }
            if (rodsRemaining > 0) {
                rod.position.set(targetX, parseFloat(altitudeSelect.value) / 1000, targetZ);
            } else {
                rod.visible = false; // Game over visually
            }
        }

        // Impact Crater and Explosion Effect
        function createImpactCrater(x, z) {
            const craterGeometry = new THREE.CircleGeometry(5, 32);
            const craterMaterial = new THREE.MeshBasicMaterial({ color: 0x8B4513 });
            const crater = new THREE.Mesh(craterGeometry, craterMaterial);
            crater.rotation.x = -Math.PI / 2;
            crater.position.set(x, 0.01, z);
            scene.add(crater);

            // Explosion Particles
            const particles = new THREE.Group();
            for (let i = 0; i < 100; i++) {
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.2, 8, 8),
                    new THREE.MeshBasicMaterial({ color: Math.random() > 0.5 ? 0xFF4500 : 0x808080 })
                );
                particle.position.set(
                    x + (Math.random() - 0.5) * 20,
                    Math.random() * 10,
                    z + (Math.random() - 0.5) * 20
                );
                particle.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 5,
                    Math.random() * 5,
                    (Math.random() - 0.5) * 5
                );
                particles.add(particle);
            }
            scene.add(particles);

            // Animate Particles
            let time = 0;
            const particleAnimation = setInterval(() => {
                time += 0.016;
                particles.children.forEach(p => {
                    p.position.add(p.userData.velocity.clone().multiplyScalar(0.016));
                    p.userData.velocity.y -= 9.81 * 0.016; // Gravity
                });
                if (time > 2) {
                    scene.remove(particles);
                    clearInterval(particleAnimation);
                }
            }, 16);
        }

        // Handle Window Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize
        updateTargetPosition();
        animate();
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Rods from God: Impact Simulator</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { width: 100vw; height: 100vh; display: block; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // Three.js Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000000);
        camera.position.set(0, 7000, 10000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });

        // Earth
        const earthRadius = 6371; // km
        const earth = new THREE.Mesh(
            new THREE.SphereGeometry(earthRadius, 128, 128),
            new THREE.MeshPhongMaterial({
                map: new THREE.TextureLoader().load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg'),
                bumpMap: new THREE.TextureLoader().load('https://threejs.org/examples/textures/planets/earth_bump_2048.jpg'),
                bumpScale: 10,
                shininess: 20
            })
        );
        earth.receiveShadow = true;
        scene.add(earth);

        // Atmosphere
        const atmosphere = new THREE.Mesh(
            new THREE.SphereGeometry(earthRadius * 1.015, 128, 128),
            new THREE.MeshBasicMaterial({
                color: 0x00aaff,
                transparent: true,
                opacity: 0.4,
                side: THREE.BackSide
            })
        );
        scene.add(atmosphere);

        // Lighting
        const sunLight = new THREE.DirectionalLight(0xffffff, 1);
        sunLight.position.set(10000, 10000, 10000);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 100;
        sunLight.shadow.camera.far = 20000;
        sunLight.shadow.camera.left = -10000;
        sunLight.shadow.camera.right = 10000;
        sunLight.shadow.camera.top = 10000;
        sunLight.shadow.camera.bottom = -10000;
        scene.add(sunLight);
        scene.add(new THREE.AmbientLight(0x333333));

        // Rod
        const rodGeometry = new THREE.CylinderGeometry(5, 5, 50, 32);
        const rodMaterial = new THREE.MeshPhongMaterial({
            color: 0xaaaaaa,
            emissive: 0xff5500,
            emissiveIntensity: 0,
            shininess: 50,
            specular: 0x555555
        });
        const rod = new THREE.Mesh(rodGeometry, rodMaterial);
        rod.position.set(0, 36000, 0); // Start at 36,000 km
        rod.velocity = new THREE.Vector3(0, -500, 0); // Initial velocity toward Earth
        rod.mass = 10000; // 10 tons
        rod.castShadow = true;
        scene.add(rod);

        // Impact Effects
        const particleGeometry = new THREE.BufferGeometry();
        const particleCount = 20000;
        const positions = new Float32Array(particleCount * 3);
        const velocities = new Float32Array(particleCount * 3);
        const lifetimes = new Float32Array(particleCount);
        particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const particleMaterial = new THREE.PointsMaterial({
            color: 0xffaa00,
            size: 10,
            transparent: true,
            blending: THREE.AdditiveBlending
        });
        const particles = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particles);

        const shockwaveGeometry = new THREE.PlaneGeometry(1000, 1000);
        const shockwaveMaterial = new THREE.MeshBasicMaterial({
            color: 0xff5500,
            transparent: true,
            opacity: 0,
            side: THREE.DoubleSide
        });
        const shockwave = new THREE.Mesh(shockwaveGeometry, shockwaveMaterial);
        shockwave.rotation.x = -Math.PI / 2;
        shockwave.visible = false;
        scene.add(shockwave);

        // Physics Constants (scaled for km)
        const G = 6.67430e-11 * 1e9;
        const M = 5.972e24;
        let impactOccurred = false;

        // Animation Loop
        let lastTime = performance.now();
        function animate(time) {
            const dt = Math.min((time - lastTime) / 1000, 0.1);
            lastTime = time;

            if (!impactOccurred) {
                // Physics Update
                const r = rod.position.length();
                const altitude = r - earthRadius;
                let simSpeed = 10;

                if (altitude > 0) {
                    // Gravity
                    const gravity = rod.position.clone().normalize().multiplyScalar(-G * M / (r * r));
                    rod.velocity.add(gravity.multiplyScalar(dt * simSpeed));

                    // Atmospheric Drag
                    if (altitude < 130) {
                        const density = 1.225 * Math.exp(-altitude / 7.2);
                        const vMag = rod.velocity.length();
                        const drag = rod.velocity.clone().normalize().multiplyScalar(-0.5 * density * vMag * vMag * 0.015);
                        rod.velocity.add(drag.multiplyScalar(dt * simSpeed));
                    }

                    // Dynamic Speed
                    const timeToImpact = -altitude / rod.velocity.y;
                    if (timeToImpact <= 5) simSpeed = Math.max(1, simSpeed * (timeToImpact / 5));
                    if (timeToImpact <= 0.5) simSpeed = Math.max(0.1, simSpeed * (timeToImpact / 0.5));

                    rod.position.add(rod.velocity.clone().multiplyScalar(dt * simSpeed));
                    rod.material.emissiveIntensity = Math.min(2, (130 - altitude) / 65);

                    // Camera Zoom
                    camera.position.lerp(rod.position.clone().normalize().multiplyScalar(10000), dt * 2);
                    camera.lookAt(rod.position);
                } else {
                    // Impact
                    impactOccurred = true;
                    const impactPoint = rod.position.clone();

                    // Ejecta
                    for (let i = 0; i < particleCount; i++) {
                        const angle = Math.random() * 2 * Math.PI;
                        const speed = Math.random() * 200 + 50;
                        positions[i * 3] = impactPoint.x;
                        positions[i * 3 + 1] = impactPoint.y;
                        positions[i * 3 + 2] = impactPoint.z;
                        velocities[i * 3] = Math.cos(angle) * speed;
                        velocities[i * 3 + 1] = Math.random() * 300 + 100;
                        velocities[i * 3 + 2] = Math.sin(angle) * speed;
                        lifetimes[i] = 5;
                    }
                    particleGeometry.attributes.position.needsUpdate = true;

                    // Shockwave
                    shockwave.position.copy(impactPoint);
                    shockwave.visible = true;
                    shockwave.scale.set(1, 1, 1);
                    shockwaveMaterial.opacity = 0.8;

                    // Crater (simplified displacement)
                    earth.scale.multiplyScalar(0.999);
                    scene.remove(rod);
                }
            } else {
                // Post-Impact Effects
                for (let i = 0; i < particleCount; i++) {
                    if (lifetimes[i] > 0) {
                        positions[i * 3] += velocities[i * 3] * dt;
                        positions[i * 3 + 1] += (velocities[i * 3 + 1] -= 9.81 * dt) * dt;
                        positions[i * 3 + 2] += velocities[i * 3 + 2] * dt;
                        lifetimes[i] -= dt;
                        if (lifetimes[i] <= 0) positions[i * 3 + 1] = -10000;
                    }
                }
                particleGeometry.attributes.position.needsUpdate = true;

                shockwave.scale.multiplyScalar(1 + dt * 5);
                shockwaveMaterial.opacity -= dt * 0.5;
                if (shockwaveMaterial.opacity <= 0) shockwave.visible = false;

                camera.position.lerp(rod.position.clone().normalize().multiplyScalar(8000), dt);
                camera.lookAt(rod.position);
            }

            earth.rotation.y += dt * 0.05;
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        requestAnimationFrame(animate);
    </script>
</body>
</html>

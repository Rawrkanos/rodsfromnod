<!DOCTYPE html>
<html>
<head>
    <title>Rods from God Game</title>
    <style>body { margin: 0; overflow: hidden; }</style>
</head>
<body>
    <div id="game"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('game').appendChild(renderer.domElement);

        // Earth
        const R_e = 100;
        const earth = new THREE.Mesh(
            new THREE.SphereGeometry(R_e, 32, 32),
            new THREE.MeshBasicMaterial({ color: 0x0000ff })
        );
        scene.add(earth);

        // Satellite
        const r_orbit = 110;
        const satellite = new THREE.Mesh(
            new THREE.BoxGeometry(5, 5, 5),
            new THREE.MeshBasicMaterial({ color: 0xff0000 })
        );
        satellite.position.set(r_orbit, 0, 0);
        scene.add(satellite);

        // Targets (example: one at equator)
        const target = new THREE.Mesh(
            new THREE.SphereGeometry(2, 16, 16),
            new THREE.MeshBasicMaterial({ color: 0xffff00 })
        );
        target.position.set(R_e, 0, 0); // lon=0, lat=0
        target.lat = 0;
        target.lon = 0;
        earth.add(target);

        // Simulation parameters
        const mu = 1;
        const omega = Math.sqrt(mu / Math.pow(r_orbit / R_e, 3));
        const T_orbit = 2 * Math.PI / omega;
        const timeScale = 30 / T_orbit; // Orbital period = 30s
        const omega_earth = omega / 16; // Earth slower than orbit
        const dt = 1 / 60;
        const dt_sim = dt * timeScale;

        let theta = 0;
        let rods = [];
        let time = 0;

        // Rod deployment
        function deployRod() {
            const rod = new THREE.Mesh(
                new THREE.CylinderGeometry(1, 1, 10, 16),
                new THREE.MeshBasicMaterial({ color: 0x888888 })
            );
            rod.position.copy(satellite.position);
            const v_sat = new THREE.Vector3(
                -Math.sqrt(mu / (r_orbit / R_e)) * Math.sin(theta),
                Math.sqrt(mu / (r_orbit / R_e)) * Math.cos(theta),
                0
            );
            const dir = satellite.position.clone().normalize().multiplyScalar(-1);
            rod.velocity = v_sat.add(dir.multiplyScalar(0.1));
            rod.startTime = time;
            scene.add(rod);
            rods.push(rod);
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Update satellite
            theta += omega * dt_sim;
            satellite.position.set(r_orbit * Math.cos(theta), r_orbit * Math.sin(theta), 0);
            camera.position.set(satellite.position.x + 50, satellite.position.y + 50, 50);
            camera.lookAt(satellite.position);

            // Rotate Earth
            earth.rotation.z += omega_earth * dt_sim;

            // Update rods
            rods = rods.filter(rod => {
                let r = rod.position.clone();
                let r_mag = r.length() / R_e;
                if (r_mag <= 1) {
                    // Impact: check hit
                    let t_impact = time - rod.startTime;
                    let theta_earth = omega_earth * t_impact;
                    let r_world = rod.position;
                    let x_local = r_world.x * Math.cos(theta_earth) + r_world.y * Math.sin(theta_earth);
                    let y_local = -r_world.x * Math.sin(theta_earth) + r_world.y * Math.cos(theta_earth);
                    let z_local = r_world.z;
                    let lat = Math.asin(z_local / R_e);
                    let lon = Math.atan2(y_local, x_local);
                    scene.remove(rod);
                    console.log(`Hit at lat: ${lat}, lon: ${lon}`); // Check against target.lat, target.lon
                    return false;
                }
                let a = r.multiplyScalar(-mu / (r_mag * r_mag * r_mag));
                rod.velocity.addScaledVector(a, dt_sim);
                rod.position.addScaledVector(rod.velocity, dt_sim);
                return true;
            });

            time += dt_sim;
            renderer.render(scene, camera);
        }

        // Controls
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') deployRod();
        });

        animate();
    </script>
</body>
</html>

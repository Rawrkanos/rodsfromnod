<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Rods from God: Orbital Dominion</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { width: 100vw; height: 100vh; display: block; }
        #ui { position: absolute; top: 10px; left: 10px; color: #fff; font-family: Arial, sans-serif; }
        button { padding: 5px 10px; margin: 2px; background: #333; color: #fff; border: none; cursor: pointer; }
        button:hover { background: #555; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="ui">
        <div>Resources: <span id="metal">0</span> Metal | <span id="influence">0</span> Influence | <span id="tech">0</span> Tech</div>
        <div>Satellites: <span id="satellites">1</span> | Rods: <span id="rods">1</span></div>
        <button onclick="dropRod()">Drop Rod</button>
        <button onclick="upgradeSatellites()">Upgrade Satellites (50 Metal)</button>
        <button onclick="upgradeRods()">Upgrade Rods (100 Metal)</button>
        <button onclick="unlockAutomation()">Unlock Automation (200 Tech)</button>
        <button onclick="resetWorld()">Reset World (Endgame)</button>
    </div>

    <script>
        // Game State
        let gameState = {
            metal: 0, influence: 0, tech: 0,
            satellites: 1, rods: 1, rodPower: 1,
            automation: false, phase: 1,
            timePlayed: 0, lastDrop: 0
        };

        // Canvas and WebGPU Setup
        const canvas = document.getElementById('canvas');
        const adapter = await navigator.gpu.requestAdapter();
        const device = await adapter.requestDevice();
        const context = canvas.getContext('webgpu');
        const format = navigator.gpu.getPreferredCanvasFormat();
        context.configure({ device, format });

        // Resize Canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Vertex Shader (WGSL)
        const vertexShader = `
            struct Uniforms {
                modelViewProj : mat4x4<f32>,
            };
            @binding(0) @group(0) var<uniform> uniforms : Uniforms;

            struct VertexInput {
                @location(0) position : vec3<f32>,
                @location(1) normal : vec3<f32>,
            };
            struct VertexOutput {
                @builtin(position) position : vec4<f32>,
                @location(0) normal : vec3<f32>,
            };

            @vertex
            fn main(input : VertexInput) -> VertexOutput {
                var output : VertexOutput;
                output.position = uniforms.modelViewProj * vec4<f32>(input.position, 1.0);
                output.normal = input.normal;
                return output;
            }
        `;

        // Fragment Shader (PBR + Atmospheric Effects)
        const fragmentShader = `
            struct FragmentInput {
                @location(0) normal : vec3<f32>,
            };
            @fragment
            fn main(input : FragmentInput) -> @location(0) vec4<f32> {
                let lightDir = normalize(vec3<f32>(1.0, 1.0, 1.0));
                let diffuse = max(dot(input.normal, lightDir), 0.1);
                let baseColor = vec3<f32>(0.7, 0.7, 0.8); // Earth-like albedo
                return vec4<f32>(baseColor * diffuse, 1.0);
            }
        `;

        // Compute Shader (Orbital Physics + Impact)
        const computeShader = `
            struct Rod {
                position : vec3<f32>,
                velocity : vec3<f32>,
                mass : f32,
            };
            @binding(0) @group(0) var<storage, read_write> rods : array<Rod>;
            @binding(1) @group(0) var<uniform> time : f32;

            @compute @workgroup_size(64)
            fn main(@builtin(global_invocation_id) id : vec3<u32>) {
                let i = id.x;
                if (i >= arrayLength(&rods)) { return; }

                // Gravity (simplified Earth-centered)
                let G = 6.67430e-11;
                let M = 5.972e24; // Earth mass
                let r = length(rods[i].position);
                let accel = -G * M / (r * r * r) * rods[i].position;

                // Drag (basic atmospheric model)
                let altitude = r - 6371000.0; // Earth radius
                if (altitude < 100000.0) {
                    let density = exp(-altitude / 8000.0) * 1.225;
                    let drag = -0.5 * density * rods[i].velocity * length(rods[i].velocity) * 0.01;
                    accel = accel + drag / rods[i].mass;
                }

                rods[i].velocity = rods[i].velocity + accel * time;
                rods[i].position = rods[i].position + rods[i].velocity * time;

                // Impact Detection
                if (r < 6371000.0) {
                    rods[i].position = vec3<f32>(0.0, 0.0, 0.0); // Reset for simplicity
                    rods[i].velocity = vec3<f32>(0.0, 0.0, 0.0);
                }
            }
        `;

        // Earth Geometry (Simple Sphere)
        const earthRadius = 6371000; // meters
        const segments = 64;
        const vertices = [];
        const indices = [];
        for (let lat = 0; lat <= segments; lat++) {
            for (let lon = 0; lon <= segments; lon++) {
                const theta = (lat / segments) * Math.PI;
                const phi = (lon / segments) * 2 * Math.PI;
                const x = earthRadius * Math.sin(theta) * Math.cos(phi);
                const y = earthRadius * Math.cos(theta);
                const z = earthRadius * Math.sin(theta) * Math.sin(phi);
                vertices.push(x, y, z, x / earthRadius, y / earthRadius, z / earthRadius); // Position + Normal
                if (lat < segments && lon < segments) {
                    const a = lat * (segments + 1) + lon;
                    const b = a + 1;
                    const c = (lat + 1) * (segments + 1) + lon;
                    const d = c + 1;
                    indices.push(a, b, c, b, d, c);
                }
            }
        }
        const vertexBuffer = device.createBuffer({
            size: vertices.length * 4,
            usage: GPUBufferUsage.VERTEX,
            mappedAtCreation: true
        });
        new Float32Array(vertexBuffer.getMappedRange()).set(vertices);
        vertexBuffer.unmap();

        const indexBuffer = device.createBuffer({
            size: indices.length * 4,
            usage: GPUBufferUsage.INDEX,
            mappedAtCreation: true
        });
        new Uint32Array(indexBuffer.getMappedRange()).set(indices);
        indexBuffer.unmap();

        // Rods (Dynamic Buffer)
        let rods = [{ position: [0, 36000000, 0], velocity: [0, 0, 0], mass: 1000 }];
        const rodBuffer = device.createBuffer({
            size: 1024 * 16, // Room for many rods (vec3 pos, vec3 vel, f32 mass, padding)
            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
        });

        // Pipeline Setup
        const renderPipeline = device.createRenderPipeline({
            layout: 'auto',
            vertex: {
                module: device.createShaderModule({ code: vertexShader }),
                entryPoint: 'main',
                buffers: [{
                    arrayStride: 24,
                    attributes: [
                        { shaderLocation: 0, offset: 0, format: 'float32x3' }, // position
                        { shaderLocation: 1, offset: 12, format: 'float32x3' } // normal
                    ]
                }]
            },
            fragment: {
                module: device.createShaderModule({ code: fragmentShader }),
                entryPoint: 'main',
                targets: [{ format }]
            },
            primitive: { topology: 'triangle-list' },
            depthStencil: {
                depthWriteEnabled: true,
                depthCompare: 'less',
                format: 'depth24plus'
            }
        });

        const computePipeline = device.createComputePipeline({
            layout: 'auto',
            compute: {
                module: device.createShaderModule({ code: computeShader }),
                entryPoint: 'main'
            }
        });

        // Uniforms
        const uniformBuffer = device.createBuffer({
            size: 64, // mat4
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        });
        const timeBuffer = device.createBuffer({
            size: 4,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        });

        // Bind Groups
        const renderBindGroup = device.createBindGroup({
            layout: renderPipeline.getBindGroupLayout(0),
            entries: [{ binding: 0, resource: { buffer: uniformBuffer } }]
        });
        const computeBindGroup = device.createBindGroup({
            layout: computePipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: rodBuffer } },
                { binding: 1, resource: { buffer: timeBuffer } }
            ]
        });

        // Camera
        const aspect = canvas.width / canvas.height;
        const proj = mat4.perspective(Math.PI / 4, aspect, 1, 100000000);
        const view = mat4.lookAt([0, 0, 20000000], [0, 0, 0], [0, 1, 0]);
        let model = mat4.identity();

        // Game Logic
        function dropRod() {
            if (Date.now() - gameState.lastDrop < 30000 / gameState.satellites) return;
            gameState.lastDrop = Date.now();
            for (let i = 0; i < gameState.rods; i++) {
                rods.push({
                    position: [Math.random() * 1000000 - 500000, 36000000, Math.random() * 1000000 - 500000],
                    velocity: [0, -10000, 0],
                    mass: 1000 * gameState.rodPower
                });
            }
            updateRods();
            gameState.metal += 10 * gameState.rodPower;
            gameState.influence += 5 * gameState.rodPower;
            gameState.tech += 2 * gameState.rodPower;
            updateUI();
        }

        function upgradeSatellites() {
            if (gameState.metal >= 50) {
                gameState.metal -= 50;
                gameState.satellites++;
                updateUI();
            }
        }

        function upgradeRods() {
            if (gameState.metal >= 100) {
                gameState.metal -= 100;
                gameState.rods++;
                gameState.rodPower *= 1.1;
                updateUI();
            }
        }

        function unlockAutomation() {
            if (gameState.tech >= 200 && !gameState.automation) {
                gameState.tech -= 200;
                gameState.automation = true;
                updateUI();
            }
        }

        function resetWorld() {
            if (gameState.phase >= 3) {
                gameState.metal *= 2;
                gameState.influence *= 2;
                gameState.tech *= 2;
                gameState.satellites = 1;
                gameState.rods = 1;
                gameState.rodPower = 1;
                gameState.automation = false;
                gameState.phase = 1;
                rods = [{ position: [0, 36000000, 0], velocity: [0, 0, 0], mass: 1000 }];
                updateUI();
            }
        }

        function updateUI() {
            document.getElementById('metal').textContent = Math.floor(gameState.metal);
            document.getElementById('influence').textContent = Math.floor(gameState.influence);
            document.getElementById('tech').textContent = Math.floor(gameState.tech);
            document.getElementById('satellites').textContent = gameState.satellites;
            document.getElementById('rods').textContent = gameState.rods;
        }

        function updateRods() {
            const rodData = new Float32Array(rods.length * 16 / 4);
            rods.forEach((rod, i) => {
                rodData.set(rod.position.concat(rod.velocity, rod.mass), i * 4);
            });
            device.queue.writeBuffer(rodBuffer, 0, rodData);
        }

        // Animation Loop
        let lastTime = performance.now();
        function animate(time) {
            const dt = (time - lastTime) / 1000;
            lastTime = time;

            gameState.timePlayed += dt;
            if (gameState.timePlayed > 3600 * 3) gameState.phase = 2;
            if (gameState.timePlayed > 3600 * 7) gameState.phase = 3;

            if (gameState.automation) dropRod();

            // Update Uniforms
            model = mat4.rotateY(model, dt * 0.1);
            const mvp = mat4.multiply(proj, mat4.multiply(view, model));
            device.queue.writeBuffer(uniformBuffer, 0, new Float32Array(mvp));
            device.queue.writeBuffer(timeBuffer, 0, new Float32Array([dt]));

            // Compute Pass
            const commandEncoder = device.createCommandEncoder();
            const computePass = commandEncoder.beginComputePass();
            computePass.setPipeline(computePipeline);
            computePass.setBindGroup(0, computeBindGroup);
            computePass.dispatchWorkgroups(Math.ceil(rods.length / 64));
            computePass.end();

            // Render Pass
            const renderPass = commandEncoder.beginRenderPass({
                colorAttachments: [{
                    view: context.getCurrentTexture().createView(),
                    clearValue: { r: 0, g: 0, b: 0, a: 1 },
                    loadOp: 'clear',
                    storeOp: 'store'
                }],
                depthStencilAttachment: {
                    view: device.createTexture({
                        size: [canvas.width, canvas.height],
                        format: 'depth24plus',
                        usage: GPUTextureUsage.RENDER_ATTACHMENT
                    }).createView(),
                    depthClearValue: 1.0,
                    depthLoadOp: 'clear',
                    depthStoreOp: 'store'
                }
            });
            renderPass.setPipeline(renderPipeline);
            renderPass.setBindGroup(0, renderBindGroup);
            renderPass.setVertexBuffer(0, vertexBuffer);
            renderPass.setIndexBuffer(indexBuffer, 'uint32');
            renderPass.drawIndexed(indices.length);
            renderPass.end();

            device.queue.submit([commandEncoder.finish()]);
            requestAnimationFrame(animate);
        }

        // Matrix Library (Simplified)
        const mat4 = {
            identity: () => new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]),
            perspective: (fov, aspect, near, far) => {
                const f = 1 / Math.tan(fov / 2);
                const nf = 1 / (near - far);
                return new Float32Array([
                    f/aspect, 0, 0, 0,
                    0, f, 0, 0,
                    0, 0, (far + near) * nf, -1,
                    0, 0, 2 * far * near * nf, 0
                ]);
            },
            lookAt: (eye, center, up) => {
                const z = vec3.normalize(vec3.subtract(eye, center));
                const x = vec3.normalize(vec3.cross(up, z));
                const y = vec3.cross(z, x);
                return new Float32Array([
                    x[0], y[0], z[0], 0,
                    x[1], y[1], z[1], 0,
                    x[2], y[2], z[2], 0,
                    -vec3.dot(x, eye), -vec3.dot(y, eye), -vec3.dot(z, eye), 1
                ]);
            },
            rotateY: (m, angle) => {
                const c = Math.cos(angle), s = Math.sin(angle);
                const m0 = m[0], m4 = m[4], m8 = m[8], m12 = m[12];
                m[0] = c * m0 + s * m[8];
                m[4] = c * m4 + s * m[12];
                m[8] = -s * m0 + c * m[8];
                m[12] = -s * m4 + c * m[12];
                return m;
            },
            multiply: (a, b) => {
                const out = new Float32Array(16);
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        out[i * 4 + j] = 0;
                        for (let k = 0; k < 4; k++) {
                            out[i * 4 + j] += a[i * 4 + k] * b[k * 4 + j];
                        }
                    }
                }
                return out;
            }
        };

        const vec3 = {
            subtract: (a, b) => [a[0] - b[0], a[1] - b[1], a[2] - b[2]],
            cross: (a, b) => [
                a[1] * b[2] - a[2] * b[1],
                a[2] * b[0] - a[0] * b[2],
                a[0] * b[1] - a[1] * b[0]
            ],
            dot: (a, b) => a[0] * b[0] + a[1] * b[1] + a[2] * b[2],
            normalize: v => {
                const len = Math.sqrt(vec3.dot(v, v));
                return [v[0] / len, v[1] / len, v[2] / len];
            }
        };

        // Start Game
        requestAnimationFrame(animate);
    </script>
</body>
</html>